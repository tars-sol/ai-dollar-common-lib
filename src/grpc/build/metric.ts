// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: metric.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "metric";

export enum MetricRange {
  METRIC_RANGE_UNSPECIFIED = 0,
  WEEK = 1,
  MONTH = 2,
  YEAR = 3,
  UNRECOGNIZED = -1,
}

export function metricRangeFromJSON(object: any): MetricRange {
  switch (object) {
    case 0:
    case "METRIC_RANGE_UNSPECIFIED":
      return MetricRange.METRIC_RANGE_UNSPECIFIED;
    case 1:
    case "WEEK":
      return MetricRange.WEEK;
    case 2:
    case "MONTH":
      return MetricRange.MONTH;
    case 3:
    case "YEAR":
      return MetricRange.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricRange.UNRECOGNIZED;
  }
}

export function metricRangeToJSON(object: MetricRange): string {
  switch (object) {
    case MetricRange.METRIC_RANGE_UNSPECIFIED:
      return "METRIC_RANGE_UNSPECIFIED";
    case MetricRange.WEEK:
      return "WEEK";
    case MetricRange.MONTH:
      return "MONTH";
    case MetricRange.YEAR:
      return "YEAR";
    case MetricRange.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MetricKind {
  METRIC_KIND_UNSPECIFIED = 0,
  EARNINGS = 1,
  VIEWS = 2,
  FOLLOWERS = 3,
  SUBSCRIBERS = 4,
  UNRECOGNIZED = -1,
}

export function metricKindFromJSON(object: any): MetricKind {
  switch (object) {
    case 0:
    case "METRIC_KIND_UNSPECIFIED":
      return MetricKind.METRIC_KIND_UNSPECIFIED;
    case 1:
    case "EARNINGS":
      return MetricKind.EARNINGS;
    case 2:
    case "VIEWS":
      return MetricKind.VIEWS;
    case 3:
    case "FOLLOWERS":
      return MetricKind.FOLLOWERS;
    case 4:
    case "SUBSCRIBERS":
      return MetricKind.SUBSCRIBERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricKind.UNRECOGNIZED;
  }
}

export function metricKindToJSON(object: MetricKind): string {
  switch (object) {
    case MetricKind.METRIC_KIND_UNSPECIFIED:
      return "METRIC_KIND_UNSPECIFIED";
    case MetricKind.EARNINGS:
      return "EARNINGS";
    case MetricKind.VIEWS:
      return "VIEWS";
    case MetricKind.FOLLOWERS:
      return "FOLLOWERS";
    case MetricKind.SUBSCRIBERS:
      return "SUBSCRIBERS";
    case MetricKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetProfileMetricsRequest {
  profileId: string;
  range: MetricRange;
}

export interface ProfileMetricsResponse {
  metric: MetricKind;
  range: MetricRange;
  points: MetricPoint[];
}

export interface MetricPoint {
  date: string;
  label: string;
  value: string;
}

function createBaseGetProfileMetricsRequest(): GetProfileMetricsRequest {
  return { profileId: "", range: 0 };
}

export const GetProfileMetricsRequest: MessageFns<GetProfileMetricsRequest> = {
  encode(message: GetProfileMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    if (message.range !== 0) {
      writer.uint32(16).int32(message.range);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.range = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileMetricsRequest {
    return {
      profileId: isSet(object.profileId) ? globalThis.String(object.profileId) : "",
      range: isSet(object.range) ? metricRangeFromJSON(object.range) : 0,
    };
  },

  toJSON(message: GetProfileMetricsRequest): unknown {
    const obj: any = {};
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.range !== 0) {
      obj.range = metricRangeToJSON(message.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileMetricsRequest>, I>>(base?: I): GetProfileMetricsRequest {
    return GetProfileMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileMetricsRequest>, I>>(object: I): GetProfileMetricsRequest {
    const message = createBaseGetProfileMetricsRequest();
    message.profileId = object.profileId ?? "";
    message.range = object.range ?? 0;
    return message;
  },
};

function createBaseProfileMetricsResponse(): ProfileMetricsResponse {
  return { metric: 0, range: 0, points: [] };
}

export const ProfileMetricsResponse: MessageFns<ProfileMetricsResponse> = {
  encode(message: ProfileMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== 0) {
      writer.uint32(8).int32(message.metric);
    }
    if (message.range !== 0) {
      writer.uint32(16).int32(message.range);
    }
    for (const v of message.points) {
      MetricPoint.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.metric = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.range = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.points.push(MetricPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileMetricsResponse {
    return {
      metric: isSet(object.metric) ? metricKindFromJSON(object.metric) : 0,
      range: isSet(object.range) ? metricRangeFromJSON(object.range) : 0,
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => MetricPoint.fromJSON(e)) : [],
    };
  },

  toJSON(message: ProfileMetricsResponse): unknown {
    const obj: any = {};
    if (message.metric !== 0) {
      obj.metric = metricKindToJSON(message.metric);
    }
    if (message.range !== 0) {
      obj.range = metricRangeToJSON(message.range);
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => MetricPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileMetricsResponse>, I>>(base?: I): ProfileMetricsResponse {
    return ProfileMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileMetricsResponse>, I>>(object: I): ProfileMetricsResponse {
    const message = createBaseProfileMetricsResponse();
    message.metric = object.metric ?? 0;
    message.range = object.range ?? 0;
    message.points = object.points?.map((e) => MetricPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricPoint(): MetricPoint {
  return { date: "", label: "", value: "" };
}

export const MetricPoint: MessageFns<MetricPoint> = {
  encode(message: MetricPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricPoint {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MetricPoint): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricPoint>, I>>(base?: I): MetricPoint {
    return MetricPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricPoint>, I>>(object: I): MetricPoint {
    const message = createBaseMetricPoint();
    message.date = object.date ?? "";
    message.label = object.label ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export interface MetricsService {
  GetProfileEarningsMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse>;
  GetProfileViewsMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse>;
  GetProfileFollowersMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse>;
  GetProfileSubscribersMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse>;
}

export const MetricsServiceServiceName = "metric.MetricsService";
export class MetricsServiceClientImpl implements MetricsService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MetricsServiceServiceName;
    this.rpc = rpc;
    this.GetProfileEarningsMetrics = this.GetProfileEarningsMetrics.bind(this);
    this.GetProfileViewsMetrics = this.GetProfileViewsMetrics.bind(this);
    this.GetProfileFollowersMetrics = this.GetProfileFollowersMetrics.bind(this);
    this.GetProfileSubscribersMetrics = this.GetProfileSubscribersMetrics.bind(this);
  }
  GetProfileEarningsMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse> {
    const data = GetProfileMetricsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfileEarningsMetrics", data);
    return promise.then((data) => ProfileMetricsResponse.decode(new BinaryReader(data)));
  }

  GetProfileViewsMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse> {
    const data = GetProfileMetricsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfileViewsMetrics", data);
    return promise.then((data) => ProfileMetricsResponse.decode(new BinaryReader(data)));
  }

  GetProfileFollowersMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse> {
    const data = GetProfileMetricsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfileFollowersMetrics", data);
    return promise.then((data) => ProfileMetricsResponse.decode(new BinaryReader(data)));
  }

  GetProfileSubscribersMetrics(request: GetProfileMetricsRequest): Promise<ProfileMetricsResponse> {
    const data = GetProfileMetricsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfileSubscribersMetrics", data);
    return promise.then((data) => ProfileMetricsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
