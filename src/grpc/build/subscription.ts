// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: subscription.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "subscription";

export interface SuccessResponse {
  success: boolean;
}

export interface CreateTierRequest {
  creatorId: string;
  name: string;
  description?: string | undefined;
  accessMask?: number | undefined;
  currency?: string | undefined;
  monthlyPriceCents: number;
  annualPriceCents: number;
}

export interface UpdateTierRequest {
  tierId: string;
  name?: string | undefined;
  description?: string | undefined;
  accessMask?: number | undefined;
  currency?: string | undefined;
}

export interface UpdateTierPricesRequest {
  tierId: string;
  monthlyPriceCents?: number | undefined;
  annualPriceCents?: number | undefined;
}

export interface ToggleTierActiveRequest {
  tierId: string;
  isActive: boolean;
}

export interface GetTierRequest {
  tierId: string;
}

export interface GetCreatorTiersRequest {
  creatorId: string;
  onlyActive?: boolean | undefined;
}

export interface GetCreatorTiersResponse {
  tiers: SubscriptionTierResponse[];
}

export interface DeleteTierRequest {
  tierId: string;
  creatorId: string;
}

export interface SubscriptionTierResponse {
  id: string;
  creatorId: string;
  name: string;
  description?: string | undefined;
  stripeProductId: string;
  monthlyStripePriceId: string;
  monthlyPriceCents: number;
  annualStripePriceId: string;
  annualPriceCents: number;
  currency: string;
  accessMask: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  creatorName?: string | undefined;
  creatorAvatarUrl?: string | undefined;
}

export interface CreateCheckoutSessionRequest {
  userId: string;
  tierId: string;
  interval: string;
}

export interface CreateCheckoutSessionResponse {
  url: string;
  sessionId: string;
}

export interface CreateCheckoutSecretRequest {
  userId: string;
  tierId: string;
  interval: string;
  role: string;
  roleId: string;
}

export interface CreateCheckoutSecretResponse {
  clientSecretKey: string;
}

export interface SubscriptionPaymentRequest {
  eventId: string;
  invoiceId: string;
  subscriptionId: string;
  customerId: string;
  amountPaid: string;
  currency: string;
  periodStart: number;
  periodEnd: number;
  paidAt: number;
  userId: string;
  creatorId: string;
  tierId: string;
  interval: string;
  role: string;
  roleId: string;
}

export interface CancelSubscriptionRequest {
  userId: string;
  creatorId: string;
}

export interface ChangeSubscriptionIntervalRequest {
  userId: string;
  creatorId: string;
  interval: string;
}

export interface GetUserSubscriptionsRequest {
  userId: string;
  onlyActive?: boolean | undefined;
}

export interface GetUserSubscriptionsResponse {
  subscriptions: UserSubscriptionItem[];
}

export interface UserSubscriptionItem {
  creatorId: string;
  creatorName: string;
  creatorUsername: string;
  creatorAvatarUrl?: string | undefined;
  tierName: string;
  subscriptionType: string;
  subscriptionChargesCents: number;
  currency: string;
  status: string;
  startedAt: string;
  nextBillingAt: string;
  cancelAtPeriodEnd: boolean;
}

function createBaseSuccessResponse(): SuccessResponse {
  return { success: false };
}

export const SuccessResponse: MessageFns<SuccessResponse> = {
  encode(message: SuccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuccessResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SuccessResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuccessResponse>, I>>(base?: I): SuccessResponse {
    return SuccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuccessResponse>, I>>(object: I): SuccessResponse {
    const message = createBaseSuccessResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateTierRequest(): CreateTierRequest {
  return {
    creatorId: "",
    name: "",
    description: undefined,
    accessMask: undefined,
    currency: undefined,
    monthlyPriceCents: 0,
    annualPriceCents: 0,
  };
}

export const CreateTierRequest: MessageFns<CreateTierRequest> = {
  encode(message: CreateTierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creatorId !== "") {
      writer.uint32(10).string(message.creatorId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.accessMask !== undefined) {
      writer.uint32(32).int32(message.accessMask);
    }
    if (message.currency !== undefined) {
      writer.uint32(42).string(message.currency);
    }
    if (message.monthlyPriceCents !== 0) {
      writer.uint32(48).int32(message.monthlyPriceCents);
    }
    if (message.annualPriceCents !== 0) {
      writer.uint32(56).int32(message.annualPriceCents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.accessMask = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.monthlyPriceCents = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.annualPriceCents = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTierRequest {
    return {
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      accessMask: isSet(object.accessMask) ? globalThis.Number(object.accessMask) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
      monthlyPriceCents: isSet(object.monthlyPriceCents) ? globalThis.Number(object.monthlyPriceCents) : 0,
      annualPriceCents: isSet(object.annualPriceCents) ? globalThis.Number(object.annualPriceCents) : 0,
    };
  },

  toJSON(message: CreateTierRequest): unknown {
    const obj: any = {};
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.accessMask !== undefined) {
      obj.accessMask = Math.round(message.accessMask);
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    if (message.monthlyPriceCents !== 0) {
      obj.monthlyPriceCents = Math.round(message.monthlyPriceCents);
    }
    if (message.annualPriceCents !== 0) {
      obj.annualPriceCents = Math.round(message.annualPriceCents);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTierRequest>, I>>(base?: I): CreateTierRequest {
    return CreateTierRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTierRequest>, I>>(object: I): CreateTierRequest {
    const message = createBaseCreateTierRequest();
    message.creatorId = object.creatorId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.accessMask = object.accessMask ?? undefined;
    message.currency = object.currency ?? undefined;
    message.monthlyPriceCents = object.monthlyPriceCents ?? 0;
    message.annualPriceCents = object.annualPriceCents ?? 0;
    return message;
  },
};

function createBaseUpdateTierRequest(): UpdateTierRequest {
  return { tierId: "", name: undefined, description: undefined, accessMask: undefined, currency: undefined };
}

export const UpdateTierRequest: MessageFns<UpdateTierRequest> = {
  encode(message: UpdateTierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierId !== "") {
      writer.uint32(10).string(message.tierId);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.accessMask !== undefined) {
      writer.uint32(32).int32(message.accessMask);
    }
    if (message.currency !== undefined) {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.accessMask = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTierRequest {
    return {
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      accessMask: isSet(object.accessMask) ? globalThis.Number(object.accessMask) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
    };
  },

  toJSON(message: UpdateTierRequest): unknown {
    const obj: any = {};
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.accessMask !== undefined) {
      obj.accessMask = Math.round(message.accessMask);
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTierRequest>, I>>(base?: I): UpdateTierRequest {
    return UpdateTierRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTierRequest>, I>>(object: I): UpdateTierRequest {
    const message = createBaseUpdateTierRequest();
    message.tierId = object.tierId ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.accessMask = object.accessMask ?? undefined;
    message.currency = object.currency ?? undefined;
    return message;
  },
};

function createBaseUpdateTierPricesRequest(): UpdateTierPricesRequest {
  return { tierId: "", monthlyPriceCents: undefined, annualPriceCents: undefined };
}

export const UpdateTierPricesRequest: MessageFns<UpdateTierPricesRequest> = {
  encode(message: UpdateTierPricesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierId !== "") {
      writer.uint32(10).string(message.tierId);
    }
    if (message.monthlyPriceCents !== undefined) {
      writer.uint32(16).int32(message.monthlyPriceCents);
    }
    if (message.annualPriceCents !== undefined) {
      writer.uint32(24).int32(message.annualPriceCents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTierPricesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTierPricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.monthlyPriceCents = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.annualPriceCents = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTierPricesRequest {
    return {
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      monthlyPriceCents: isSet(object.monthlyPriceCents) ? globalThis.Number(object.monthlyPriceCents) : undefined,
      annualPriceCents: isSet(object.annualPriceCents) ? globalThis.Number(object.annualPriceCents) : undefined,
    };
  },

  toJSON(message: UpdateTierPricesRequest): unknown {
    const obj: any = {};
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.monthlyPriceCents !== undefined) {
      obj.monthlyPriceCents = Math.round(message.monthlyPriceCents);
    }
    if (message.annualPriceCents !== undefined) {
      obj.annualPriceCents = Math.round(message.annualPriceCents);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTierPricesRequest>, I>>(base?: I): UpdateTierPricesRequest {
    return UpdateTierPricesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTierPricesRequest>, I>>(object: I): UpdateTierPricesRequest {
    const message = createBaseUpdateTierPricesRequest();
    message.tierId = object.tierId ?? "";
    message.monthlyPriceCents = object.monthlyPriceCents ?? undefined;
    message.annualPriceCents = object.annualPriceCents ?? undefined;
    return message;
  },
};

function createBaseToggleTierActiveRequest(): ToggleTierActiveRequest {
  return { tierId: "", isActive: false };
}

export const ToggleTierActiveRequest: MessageFns<ToggleTierActiveRequest> = {
  encode(message: ToggleTierActiveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierId !== "") {
      writer.uint32(10).string(message.tierId);
    }
    if (message.isActive !== false) {
      writer.uint32(16).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleTierActiveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleTierActiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleTierActiveRequest {
    return {
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: ToggleTierActiveRequest): unknown {
    const obj: any = {};
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToggleTierActiveRequest>, I>>(base?: I): ToggleTierActiveRequest {
    return ToggleTierActiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleTierActiveRequest>, I>>(object: I): ToggleTierActiveRequest {
    const message = createBaseToggleTierActiveRequest();
    message.tierId = object.tierId ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetTierRequest(): GetTierRequest {
  return { tierId: "" };
}

export const GetTierRequest: MessageFns<GetTierRequest> = {
  encode(message: GetTierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierId !== "") {
      writer.uint32(10).string(message.tierId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTierRequest {
    return { tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "" };
  },

  toJSON(message: GetTierRequest): unknown {
    const obj: any = {};
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTierRequest>, I>>(base?: I): GetTierRequest {
    return GetTierRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTierRequest>, I>>(object: I): GetTierRequest {
    const message = createBaseGetTierRequest();
    message.tierId = object.tierId ?? "";
    return message;
  },
};

function createBaseGetCreatorTiersRequest(): GetCreatorTiersRequest {
  return { creatorId: "", onlyActive: undefined };
}

export const GetCreatorTiersRequest: MessageFns<GetCreatorTiersRequest> = {
  encode(message: GetCreatorTiersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creatorId !== "") {
      writer.uint32(10).string(message.creatorId);
    }
    if (message.onlyActive !== undefined) {
      writer.uint32(16).bool(message.onlyActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCreatorTiersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCreatorTiersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.onlyActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCreatorTiersRequest {
    return {
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      onlyActive: isSet(object.onlyActive) ? globalThis.Boolean(object.onlyActive) : undefined,
    };
  },

  toJSON(message: GetCreatorTiersRequest): unknown {
    const obj: any = {};
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.onlyActive !== undefined) {
      obj.onlyActive = message.onlyActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCreatorTiersRequest>, I>>(base?: I): GetCreatorTiersRequest {
    return GetCreatorTiersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCreatorTiersRequest>, I>>(object: I): GetCreatorTiersRequest {
    const message = createBaseGetCreatorTiersRequest();
    message.creatorId = object.creatorId ?? "";
    message.onlyActive = object.onlyActive ?? undefined;
    return message;
  },
};

function createBaseGetCreatorTiersResponse(): GetCreatorTiersResponse {
  return { tiers: [] };
}

export const GetCreatorTiersResponse: MessageFns<GetCreatorTiersResponse> = {
  encode(message: GetCreatorTiersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tiers) {
      SubscriptionTierResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCreatorTiersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCreatorTiersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tiers.push(SubscriptionTierResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCreatorTiersResponse {
    return {
      tiers: globalThis.Array.isArray(object?.tiers)
        ? object.tiers.map((e: any) => SubscriptionTierResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCreatorTiersResponse): unknown {
    const obj: any = {};
    if (message.tiers?.length) {
      obj.tiers = message.tiers.map((e) => SubscriptionTierResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCreatorTiersResponse>, I>>(base?: I): GetCreatorTiersResponse {
    return GetCreatorTiersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCreatorTiersResponse>, I>>(object: I): GetCreatorTiersResponse {
    const message = createBaseGetCreatorTiersResponse();
    message.tiers = object.tiers?.map((e) => SubscriptionTierResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteTierRequest(): DeleteTierRequest {
  return { tierId: "", creatorId: "" };
}

export const DeleteTierRequest: MessageFns<DeleteTierRequest> = {
  encode(message: DeleteTierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierId !== "") {
      writer.uint32(10).string(message.tierId);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTierRequest {
    return {
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
    };
  },

  toJSON(message: DeleteTierRequest): unknown {
    const obj: any = {};
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTierRequest>, I>>(base?: I): DeleteTierRequest {
    return DeleteTierRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTierRequest>, I>>(object: I): DeleteTierRequest {
    const message = createBaseDeleteTierRequest();
    message.tierId = object.tierId ?? "";
    message.creatorId = object.creatorId ?? "";
    return message;
  },
};

function createBaseSubscriptionTierResponse(): SubscriptionTierResponse {
  return {
    id: "",
    creatorId: "",
    name: "",
    description: undefined,
    stripeProductId: "",
    monthlyStripePriceId: "",
    monthlyPriceCents: 0,
    annualStripePriceId: "",
    annualPriceCents: 0,
    currency: "",
    accessMask: 0,
    isActive: false,
    createdAt: "",
    updatedAt: "",
    creatorName: undefined,
    creatorAvatarUrl: undefined,
  };
}

export const SubscriptionTierResponse: MessageFns<SubscriptionTierResponse> = {
  encode(message: SubscriptionTierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.stripeProductId !== "") {
      writer.uint32(42).string(message.stripeProductId);
    }
    if (message.monthlyStripePriceId !== "") {
      writer.uint32(50).string(message.monthlyStripePriceId);
    }
    if (message.monthlyPriceCents !== 0) {
      writer.uint32(56).int32(message.monthlyPriceCents);
    }
    if (message.annualStripePriceId !== "") {
      writer.uint32(66).string(message.annualStripePriceId);
    }
    if (message.annualPriceCents !== 0) {
      writer.uint32(72).int32(message.annualPriceCents);
    }
    if (message.currency !== "") {
      writer.uint32(82).string(message.currency);
    }
    if (message.accessMask !== 0) {
      writer.uint32(88).int32(message.accessMask);
    }
    if (message.isActive !== false) {
      writer.uint32(96).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    if (message.creatorName !== undefined) {
      writer.uint32(122).string(message.creatorName);
    }
    if (message.creatorAvatarUrl !== undefined) {
      writer.uint32(130).string(message.creatorAvatarUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionTierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionTierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stripeProductId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.monthlyStripePriceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.monthlyPriceCents = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.annualStripePriceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.annualPriceCents = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.accessMask = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.creatorName = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.creatorAvatarUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionTierResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      stripeProductId: isSet(object.stripeProductId) ? globalThis.String(object.stripeProductId) : "",
      monthlyStripePriceId: isSet(object.monthlyStripePriceId) ? globalThis.String(object.monthlyStripePriceId) : "",
      monthlyPriceCents: isSet(object.monthlyPriceCents) ? globalThis.Number(object.monthlyPriceCents) : 0,
      annualStripePriceId: isSet(object.annualStripePriceId) ? globalThis.String(object.annualStripePriceId) : "",
      annualPriceCents: isSet(object.annualPriceCents) ? globalThis.Number(object.annualPriceCents) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      accessMask: isSet(object.accessMask) ? globalThis.Number(object.accessMask) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      creatorName: isSet(object.creatorName) ? globalThis.String(object.creatorName) : undefined,
      creatorAvatarUrl: isSet(object.creatorAvatarUrl) ? globalThis.String(object.creatorAvatarUrl) : undefined,
    };
  },

  toJSON(message: SubscriptionTierResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.stripeProductId !== "") {
      obj.stripeProductId = message.stripeProductId;
    }
    if (message.monthlyStripePriceId !== "") {
      obj.monthlyStripePriceId = message.monthlyStripePriceId;
    }
    if (message.monthlyPriceCents !== 0) {
      obj.monthlyPriceCents = Math.round(message.monthlyPriceCents);
    }
    if (message.annualStripePriceId !== "") {
      obj.annualStripePriceId = message.annualStripePriceId;
    }
    if (message.annualPriceCents !== 0) {
      obj.annualPriceCents = Math.round(message.annualPriceCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.accessMask !== 0) {
      obj.accessMask = Math.round(message.accessMask);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.creatorName !== undefined) {
      obj.creatorName = message.creatorName;
    }
    if (message.creatorAvatarUrl !== undefined) {
      obj.creatorAvatarUrl = message.creatorAvatarUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionTierResponse>, I>>(base?: I): SubscriptionTierResponse {
    return SubscriptionTierResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionTierResponse>, I>>(object: I): SubscriptionTierResponse {
    const message = createBaseSubscriptionTierResponse();
    message.id = object.id ?? "";
    message.creatorId = object.creatorId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.stripeProductId = object.stripeProductId ?? "";
    message.monthlyStripePriceId = object.monthlyStripePriceId ?? "";
    message.monthlyPriceCents = object.monthlyPriceCents ?? 0;
    message.annualStripePriceId = object.annualStripePriceId ?? "";
    message.annualPriceCents = object.annualPriceCents ?? 0;
    message.currency = object.currency ?? "";
    message.accessMask = object.accessMask ?? 0;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.creatorName = object.creatorName ?? undefined;
    message.creatorAvatarUrl = object.creatorAvatarUrl ?? undefined;
    return message;
  },
};

function createBaseCreateCheckoutSessionRequest(): CreateCheckoutSessionRequest {
  return { userId: "", tierId: "", interval: "" };
}

export const CreateCheckoutSessionRequest: MessageFns<CreateCheckoutSessionRequest> = {
  encode(message: CreateCheckoutSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.tierId !== "") {
      writer.uint32(18).string(message.tierId);
    }
    if (message.interval !== "") {
      writer.uint32(26).string(message.interval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckoutSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckoutSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interval = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckoutSessionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
    };
  },

  toJSON(message: CreateCheckoutSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.interval !== "") {
      obj.interval = message.interval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckoutSessionRequest>, I>>(base?: I): CreateCheckoutSessionRequest {
    return CreateCheckoutSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckoutSessionRequest>, I>>(object: I): CreateCheckoutSessionRequest {
    const message = createBaseCreateCheckoutSessionRequest();
    message.userId = object.userId ?? "";
    message.tierId = object.tierId ?? "";
    message.interval = object.interval ?? "";
    return message;
  },
};

function createBaseCreateCheckoutSessionResponse(): CreateCheckoutSessionResponse {
  return { url: "", sessionId: "" };
}

export const CreateCheckoutSessionResponse: MessageFns<CreateCheckoutSessionResponse> = {
  encode(message: CreateCheckoutSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckoutSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckoutSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckoutSessionResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: CreateCheckoutSessionResponse): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckoutSessionResponse>, I>>(base?: I): CreateCheckoutSessionResponse {
    return CreateCheckoutSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckoutSessionResponse>, I>>(
    object: I,
  ): CreateCheckoutSessionResponse {
    const message = createBaseCreateCheckoutSessionResponse();
    message.url = object.url ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCreateCheckoutSecretRequest(): CreateCheckoutSecretRequest {
  return { userId: "", tierId: "", interval: "", role: "", roleId: "" };
}

export const CreateCheckoutSecretRequest: MessageFns<CreateCheckoutSecretRequest> = {
  encode(message: CreateCheckoutSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.tierId !== "") {
      writer.uint32(18).string(message.tierId);
    }
    if (message.interval !== "") {
      writer.uint32(26).string(message.interval);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.roleId !== "") {
      writer.uint32(42).string(message.roleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckoutSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckoutSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interval = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckoutSecretRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
    };
  },

  toJSON(message: CreateCheckoutSecretRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.interval !== "") {
      obj.interval = message.interval;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckoutSecretRequest>, I>>(base?: I): CreateCheckoutSecretRequest {
    return CreateCheckoutSecretRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckoutSecretRequest>, I>>(object: I): CreateCheckoutSecretRequest {
    const message = createBaseCreateCheckoutSecretRequest();
    message.userId = object.userId ?? "";
    message.tierId = object.tierId ?? "";
    message.interval = object.interval ?? "";
    message.role = object.role ?? "";
    message.roleId = object.roleId ?? "";
    return message;
  },
};

function createBaseCreateCheckoutSecretResponse(): CreateCheckoutSecretResponse {
  return { clientSecretKey: "" };
}

export const CreateCheckoutSecretResponse: MessageFns<CreateCheckoutSecretResponse> = {
  encode(message: CreateCheckoutSecretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientSecretKey !== "") {
      writer.uint32(10).string(message.clientSecretKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckoutSecretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckoutSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientSecretKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckoutSecretResponse {
    return { clientSecretKey: isSet(object.clientSecretKey) ? globalThis.String(object.clientSecretKey) : "" };
  },

  toJSON(message: CreateCheckoutSecretResponse): unknown {
    const obj: any = {};
    if (message.clientSecretKey !== "") {
      obj.clientSecretKey = message.clientSecretKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckoutSecretResponse>, I>>(base?: I): CreateCheckoutSecretResponse {
    return CreateCheckoutSecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckoutSecretResponse>, I>>(object: I): CreateCheckoutSecretResponse {
    const message = createBaseCreateCheckoutSecretResponse();
    message.clientSecretKey = object.clientSecretKey ?? "";
    return message;
  },
};

function createBaseSubscriptionPaymentRequest(): SubscriptionPaymentRequest {
  return {
    eventId: "",
    invoiceId: "",
    subscriptionId: "",
    customerId: "",
    amountPaid: "",
    currency: "",
    periodStart: 0,
    periodEnd: 0,
    paidAt: 0,
    userId: "",
    creatorId: "",
    tierId: "",
    interval: "",
    role: "",
    roleId: "",
  };
}

export const SubscriptionPaymentRequest: MessageFns<SubscriptionPaymentRequest> = {
  encode(message: SubscriptionPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.invoiceId !== "") {
      writer.uint32(18).string(message.invoiceId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(26).string(message.subscriptionId);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.amountPaid !== "") {
      writer.uint32(42).string(message.amountPaid);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.periodStart !== 0) {
      writer.uint32(56).int64(message.periodStart);
    }
    if (message.periodEnd !== 0) {
      writer.uint32(64).int64(message.periodEnd);
    }
    if (message.paidAt !== 0) {
      writer.uint32(72).int64(message.paidAt);
    }
    if (message.userId !== "") {
      writer.uint32(82).string(message.userId);
    }
    if (message.creatorId !== "") {
      writer.uint32(90).string(message.creatorId);
    }
    if (message.tierId !== "") {
      writer.uint32(98).string(message.tierId);
    }
    if (message.interval !== "") {
      writer.uint32(106).string(message.interval);
    }
    if (message.role !== "") {
      writer.uint32(114).string(message.role);
    }
    if (message.roleId !== "") {
      writer.uint32(122).string(message.roleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amountPaid = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.periodStart = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.periodEnd = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.paidAt = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tierId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.interval = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionPaymentRequest {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : "",
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      amountPaid: isSet(object.amountPaid) ? globalThis.String(object.amountPaid) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      periodStart: isSet(object.periodStart) ? globalThis.Number(object.periodStart) : 0,
      periodEnd: isSet(object.periodEnd) ? globalThis.Number(object.periodEnd) : 0,
      paidAt: isSet(object.paidAt) ? globalThis.Number(object.paidAt) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      tierId: isSet(object.tierId) ? globalThis.String(object.tierId) : "",
      interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
    };
  },

  toJSON(message: SubscriptionPaymentRequest): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.invoiceId !== "") {
      obj.invoiceId = message.invoiceId;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.amountPaid !== "") {
      obj.amountPaid = message.amountPaid;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.periodStart !== 0) {
      obj.periodStart = Math.round(message.periodStart);
    }
    if (message.periodEnd !== 0) {
      obj.periodEnd = Math.round(message.periodEnd);
    }
    if (message.paidAt !== 0) {
      obj.paidAt = Math.round(message.paidAt);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.tierId !== "") {
      obj.tierId = message.tierId;
    }
    if (message.interval !== "") {
      obj.interval = message.interval;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionPaymentRequest>, I>>(base?: I): SubscriptionPaymentRequest {
    return SubscriptionPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionPaymentRequest>, I>>(object: I): SubscriptionPaymentRequest {
    const message = createBaseSubscriptionPaymentRequest();
    message.eventId = object.eventId ?? "";
    message.invoiceId = object.invoiceId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.customerId = object.customerId ?? "";
    message.amountPaid = object.amountPaid ?? "";
    message.currency = object.currency ?? "";
    message.periodStart = object.periodStart ?? 0;
    message.periodEnd = object.periodEnd ?? 0;
    message.paidAt = object.paidAt ?? 0;
    message.userId = object.userId ?? "";
    message.creatorId = object.creatorId ?? "";
    message.tierId = object.tierId ?? "";
    message.interval = object.interval ?? "";
    message.role = object.role ?? "";
    message.roleId = object.roleId ?? "";
    return message;
  },
};

function createBaseCancelSubscriptionRequest(): CancelSubscriptionRequest {
  return { userId: "", creatorId: "" };
}

export const CancelSubscriptionRequest: MessageFns<CancelSubscriptionRequest> = {
  encode(message: CancelSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSubscriptionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
    };
  },

  toJSON(message: CancelSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSubscriptionRequest>, I>>(base?: I): CancelSubscriptionRequest {
    return CancelSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSubscriptionRequest>, I>>(object: I): CancelSubscriptionRequest {
    const message = createBaseCancelSubscriptionRequest();
    message.userId = object.userId ?? "";
    message.creatorId = object.creatorId ?? "";
    return message;
  },
};

function createBaseChangeSubscriptionIntervalRequest(): ChangeSubscriptionIntervalRequest {
  return { userId: "", creatorId: "", interval: "" };
}

export const ChangeSubscriptionIntervalRequest: MessageFns<ChangeSubscriptionIntervalRequest> = {
  encode(message: ChangeSubscriptionIntervalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    if (message.interval !== "") {
      writer.uint32(26).string(message.interval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeSubscriptionIntervalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeSubscriptionIntervalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interval = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeSubscriptionIntervalRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
    };
  },

  toJSON(message: ChangeSubscriptionIntervalRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.interval !== "") {
      obj.interval = message.interval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeSubscriptionIntervalRequest>, I>>(
    base?: I,
  ): ChangeSubscriptionIntervalRequest {
    return ChangeSubscriptionIntervalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeSubscriptionIntervalRequest>, I>>(
    object: I,
  ): ChangeSubscriptionIntervalRequest {
    const message = createBaseChangeSubscriptionIntervalRequest();
    message.userId = object.userId ?? "";
    message.creatorId = object.creatorId ?? "";
    message.interval = object.interval ?? "";
    return message;
  },
};

function createBaseGetUserSubscriptionsRequest(): GetUserSubscriptionsRequest {
  return { userId: "", onlyActive: undefined };
}

export const GetUserSubscriptionsRequest: MessageFns<GetUserSubscriptionsRequest> = {
  encode(message: GetUserSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.onlyActive !== undefined) {
      writer.uint32(16).bool(message.onlyActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.onlyActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSubscriptionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      onlyActive: isSet(object.onlyActive) ? globalThis.Boolean(object.onlyActive) : undefined,
    };
  },

  toJSON(message: GetUserSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.onlyActive !== undefined) {
      obj.onlyActive = message.onlyActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserSubscriptionsRequest>, I>>(base?: I): GetUserSubscriptionsRequest {
    return GetUserSubscriptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserSubscriptionsRequest>, I>>(object: I): GetUserSubscriptionsRequest {
    const message = createBaseGetUserSubscriptionsRequest();
    message.userId = object.userId ?? "";
    message.onlyActive = object.onlyActive ?? undefined;
    return message;
  },
};

function createBaseGetUserSubscriptionsResponse(): GetUserSubscriptionsResponse {
  return { subscriptions: [] };
}

export const GetUserSubscriptionsResponse: MessageFns<GetUserSubscriptionsResponse> = {
  encode(message: GetUserSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      UserSubscriptionItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(UserSubscriptionItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => UserSubscriptionItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => UserSubscriptionItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserSubscriptionsResponse>, I>>(base?: I): GetUserSubscriptionsResponse {
    return GetUserSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserSubscriptionsResponse>, I>>(object: I): GetUserSubscriptionsResponse {
    const message = createBaseGetUserSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => UserSubscriptionItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserSubscriptionItem(): UserSubscriptionItem {
  return {
    creatorId: "",
    creatorName: "",
    creatorUsername: "",
    creatorAvatarUrl: undefined,
    tierName: "",
    subscriptionType: "",
    subscriptionChargesCents: 0,
    currency: "",
    status: "",
    startedAt: "",
    nextBillingAt: "",
    cancelAtPeriodEnd: false,
  };
}

export const UserSubscriptionItem: MessageFns<UserSubscriptionItem> = {
  encode(message: UserSubscriptionItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creatorId !== "") {
      writer.uint32(10).string(message.creatorId);
    }
    if (message.creatorName !== "") {
      writer.uint32(18).string(message.creatorName);
    }
    if (message.creatorUsername !== "") {
      writer.uint32(26).string(message.creatorUsername);
    }
    if (message.creatorAvatarUrl !== undefined) {
      writer.uint32(34).string(message.creatorAvatarUrl);
    }
    if (message.tierName !== "") {
      writer.uint32(42).string(message.tierName);
    }
    if (message.subscriptionType !== "") {
      writer.uint32(50).string(message.subscriptionType);
    }
    if (message.subscriptionChargesCents !== 0) {
      writer.uint32(56).int32(message.subscriptionChargesCents);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.startedAt !== "") {
      writer.uint32(82).string(message.startedAt);
    }
    if (message.nextBillingAt !== "") {
      writer.uint32(90).string(message.nextBillingAt);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(96).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSubscriptionItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSubscriptionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.creatorUsername = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.creatorAvatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tierName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscriptionType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.subscriptionChargesCents = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nextBillingAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSubscriptionItem {
    return {
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      creatorName: isSet(object.creatorName) ? globalThis.String(object.creatorName) : "",
      creatorUsername: isSet(object.creatorUsername) ? globalThis.String(object.creatorUsername) : "",
      creatorAvatarUrl: isSet(object.creatorAvatarUrl) ? globalThis.String(object.creatorAvatarUrl) : undefined,
      tierName: isSet(object.tierName) ? globalThis.String(object.tierName) : "",
      subscriptionType: isSet(object.subscriptionType) ? globalThis.String(object.subscriptionType) : "",
      subscriptionChargesCents: isSet(object.subscriptionChargesCents)
        ? globalThis.Number(object.subscriptionChargesCents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      startedAt: isSet(object.startedAt) ? globalThis.String(object.startedAt) : "",
      nextBillingAt: isSet(object.nextBillingAt) ? globalThis.String(object.nextBillingAt) : "",
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd) ? globalThis.Boolean(object.cancelAtPeriodEnd) : false,
    };
  },

  toJSON(message: UserSubscriptionItem): unknown {
    const obj: any = {};
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.creatorName !== "") {
      obj.creatorName = message.creatorName;
    }
    if (message.creatorUsername !== "") {
      obj.creatorUsername = message.creatorUsername;
    }
    if (message.creatorAvatarUrl !== undefined) {
      obj.creatorAvatarUrl = message.creatorAvatarUrl;
    }
    if (message.tierName !== "") {
      obj.tierName = message.tierName;
    }
    if (message.subscriptionType !== "") {
      obj.subscriptionType = message.subscriptionType;
    }
    if (message.subscriptionChargesCents !== 0) {
      obj.subscriptionChargesCents = Math.round(message.subscriptionChargesCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.startedAt !== "") {
      obj.startedAt = message.startedAt;
    }
    if (message.nextBillingAt !== "") {
      obj.nextBillingAt = message.nextBillingAt;
    }
    if (message.cancelAtPeriodEnd !== false) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserSubscriptionItem>, I>>(base?: I): UserSubscriptionItem {
    return UserSubscriptionItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserSubscriptionItem>, I>>(object: I): UserSubscriptionItem {
    const message = createBaseUserSubscriptionItem();
    message.creatorId = object.creatorId ?? "";
    message.creatorName = object.creatorName ?? "";
    message.creatorUsername = object.creatorUsername ?? "";
    message.creatorAvatarUrl = object.creatorAvatarUrl ?? undefined;
    message.tierName = object.tierName ?? "";
    message.subscriptionType = object.subscriptionType ?? "";
    message.subscriptionChargesCents = object.subscriptionChargesCents ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.startedAt = object.startedAt ?? "";
    message.nextBillingAt = object.nextBillingAt ?? "";
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? false;
    return message;
  },
};

export interface SubscriptionService {
  CreateTier(request: CreateTierRequest): Promise<SubscriptionTierResponse>;
  UpdateTier(request: UpdateTierRequest): Promise<SubscriptionTierResponse>;
  UpdateTierPrices(request: UpdateTierPricesRequest): Promise<SubscriptionTierResponse>;
  ToggleTierActive(request: ToggleTierActiveRequest): Promise<SubscriptionTierResponse>;
  GetTier(request: GetTierRequest): Promise<SubscriptionTierResponse>;
  GetCreatorTiers(request: GetCreatorTiersRequest): Promise<GetCreatorTiersResponse>;
  DeleteTier(request: DeleteTierRequest): Promise<SuccessResponse>;
  CreateCheckoutSession(request: CreateCheckoutSessionRequest): Promise<CreateCheckoutSessionResponse>;
  CreateCheckoutSecret(request: CreateCheckoutSecretRequest): Promise<CreateCheckoutSecretResponse>;
  HandleSubscriptionPayment(request: SubscriptionPaymentRequest): Promise<SuccessResponse>;
  CancelSubscription(request: CancelSubscriptionRequest): Promise<SuccessResponse>;
  ChangeSubscriptionInterval(request: ChangeSubscriptionIntervalRequest): Promise<SuccessResponse>;
  GetUserSubscriptions(request: GetUserSubscriptionsRequest): Promise<GetUserSubscriptionsResponse>;
}

export const SubscriptionServiceServiceName = "subscription.SubscriptionService";
export class SubscriptionServiceClientImpl implements SubscriptionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SubscriptionServiceServiceName;
    this.rpc = rpc;
    this.CreateTier = this.CreateTier.bind(this);
    this.UpdateTier = this.UpdateTier.bind(this);
    this.UpdateTierPrices = this.UpdateTierPrices.bind(this);
    this.ToggleTierActive = this.ToggleTierActive.bind(this);
    this.GetTier = this.GetTier.bind(this);
    this.GetCreatorTiers = this.GetCreatorTiers.bind(this);
    this.DeleteTier = this.DeleteTier.bind(this);
    this.CreateCheckoutSession = this.CreateCheckoutSession.bind(this);
    this.CreateCheckoutSecret = this.CreateCheckoutSecret.bind(this);
    this.HandleSubscriptionPayment = this.HandleSubscriptionPayment.bind(this);
    this.CancelSubscription = this.CancelSubscription.bind(this);
    this.ChangeSubscriptionInterval = this.ChangeSubscriptionInterval.bind(this);
    this.GetUserSubscriptions = this.GetUserSubscriptions.bind(this);
  }
  CreateTier(request: CreateTierRequest): Promise<SubscriptionTierResponse> {
    const data = CreateTierRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateTier", data);
    return promise.then((data) => SubscriptionTierResponse.decode(new BinaryReader(data)));
  }

  UpdateTier(request: UpdateTierRequest): Promise<SubscriptionTierResponse> {
    const data = UpdateTierRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTier", data);
    return promise.then((data) => SubscriptionTierResponse.decode(new BinaryReader(data)));
  }

  UpdateTierPrices(request: UpdateTierPricesRequest): Promise<SubscriptionTierResponse> {
    const data = UpdateTierPricesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTierPrices", data);
    return promise.then((data) => SubscriptionTierResponse.decode(new BinaryReader(data)));
  }

  ToggleTierActive(request: ToggleTierActiveRequest): Promise<SubscriptionTierResponse> {
    const data = ToggleTierActiveRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ToggleTierActive", data);
    return promise.then((data) => SubscriptionTierResponse.decode(new BinaryReader(data)));
  }

  GetTier(request: GetTierRequest): Promise<SubscriptionTierResponse> {
    const data = GetTierRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTier", data);
    return promise.then((data) => SubscriptionTierResponse.decode(new BinaryReader(data)));
  }

  GetCreatorTiers(request: GetCreatorTiersRequest): Promise<GetCreatorTiersResponse> {
    const data = GetCreatorTiersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCreatorTiers", data);
    return promise.then((data) => GetCreatorTiersResponse.decode(new BinaryReader(data)));
  }

  DeleteTier(request: DeleteTierRequest): Promise<SuccessResponse> {
    const data = DeleteTierRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteTier", data);
    return promise.then((data) => SuccessResponse.decode(new BinaryReader(data)));
  }

  CreateCheckoutSession(request: CreateCheckoutSessionRequest): Promise<CreateCheckoutSessionResponse> {
    const data = CreateCheckoutSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateCheckoutSession", data);
    return promise.then((data) => CreateCheckoutSessionResponse.decode(new BinaryReader(data)));
  }

  CreateCheckoutSecret(request: CreateCheckoutSecretRequest): Promise<CreateCheckoutSecretResponse> {
    const data = CreateCheckoutSecretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateCheckoutSecret", data);
    return promise.then((data) => CreateCheckoutSecretResponse.decode(new BinaryReader(data)));
  }

  HandleSubscriptionPayment(request: SubscriptionPaymentRequest): Promise<SuccessResponse> {
    const data = SubscriptionPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandleSubscriptionPayment", data);
    return promise.then((data) => SuccessResponse.decode(new BinaryReader(data)));
  }

  CancelSubscription(request: CancelSubscriptionRequest): Promise<SuccessResponse> {
    const data = CancelSubscriptionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelSubscription", data);
    return promise.then((data) => SuccessResponse.decode(new BinaryReader(data)));
  }

  ChangeSubscriptionInterval(request: ChangeSubscriptionIntervalRequest): Promise<SuccessResponse> {
    const data = ChangeSubscriptionIntervalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeSubscriptionInterval", data);
    return promise.then((data) => SuccessResponse.decode(new BinaryReader(data)));
  }

  GetUserSubscriptions(request: GetUserSubscriptionsRequest): Promise<GetUserSubscriptionsResponse> {
    const data = GetUserSubscriptionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserSubscriptions", data);
    return promise.then((data) => GetUserSubscriptionsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
